# [TORF-424024] [BUR Neo4j] investigate RR integrity confirmation

[TOC]

## Description and Acceptance Criteria

### Scope

Investigate and propose the way how neo4j RR can be considered as a holistic
 and good to take backup.

There are two possible ways to do it (maybe more, it could be part
of the spike):

1. get from normal node what is the latest transaction and what is in latest
 on RR, wait till it match and shutdown then
2. check latest on normal node and RR, find out what is the delta and if
 delta is acceptable - shutdown RR for at backup(in this case what is the good
  delta should be answered as part of this spike)
3. Vendor input required for proposed solution.

### Acceptance criteria

1. Analyze Neo4J under load(DDC/DDP could be used for this purpose),
  concentrate on Leader. Preferably to have env with RR where delta in between
leader and RR can be observed.
2. identify what is the best number of outstanding transactions

## Overview

Currently the implementation of RR catchup is only checking if the difference
between leader and RR LastCommittedTxId is less than a threshold and fails
the backup if it is not.

Based on number in [DDP](https://ddp.athtem.eei.ericsson.se/php/qplot.php?site=ChungHwaTelecom_Taipei_n2l3enm1lms_LTE&oss=tor&tstart=2020-05-24+00%3A00%3A00&tend=2020-05-24+23%3A59%3A59&id=231&serverid=24467&name=transCommitted&action=jsplot)
and empirical data collected under NETsim 5K load tests, it is very hard to
define a good LastCommittedTxId delta.

This document proposes alternative algorithms to replace the current
implementation.

## Analysis of LastCommittedId delta under load

### enm202 with custom test

The tests were not conclusive because enm is not supporting the number of
transactions the load test was requesting.

### enm201 with NETsim load

The data is generated by running a script on read replica that collect at
every second the LastCommittedTxId from itself and the core servers. With
this data it possible to derive the LastCommittedTxId delta between the
servers and how many transaction are being created.

The data collected under load test in 201 Openstack environment using
NETsim 5K profile showed that:

- the LastCommittedTxId delta between core and RR is in average of 45
(st.dev. 33) with a peak of 620
- we can have an average of 100 tx/sec (stdev 40), with a peak of 1500 tx/sec

## Proposals

### A - Remove the verification

This is the simplest of the proposals and consist of simply removing the
condition based on LastCommittedTxId. The Agent would always shutdown the RR
and proceed with the backup.

In a 3 days data collected during a load test using NETsim 5K profile it was
 identified that it is possible to loose a maximum of 1500 transactions
 and an average of 100 transactions (St.Dev. 40).

Pros:

- Simplest implementation option

Cons:

- The Point in time for the core server data is not always possible.
- The LastCommitTxId in the RR can be very distant from the Core, e.g.,
if for some reason the Agent Container is restarted or the RR is still
catching up after a previous backup.

### B - Use Neo4J Bookmark

This solution uses Neo4j java client to create a node in the leader and
extracts the transaction bookmark. The bookmark is then used to create a
new session to query to find the same node in the read replica. The Neo4j
client will block until the transaction is present in RR.

This solution was test in an environment running NETsim load test with a
script that runs every second and it showed that it takes less than a
second for RR to sync.

Pros:

- Neo4j client logic is used to take care of the transaction presence
guarantees in RR
- Simple implementation using Neo4j client

Cons:

- A small increase in the image size to add Neo4j client and the
implementation

### C - Wait the Leader LastCommittedTxId

This solution uses Neo4j REST API to get the leader LastCommittedTxId at the
moment of the backup and wait until the read replica LastCommittedTxId is
greater or equals to it.

We should also implement a timeout for the catchup protocol as we can have
network issues while taking backup.

This solution supports a sequence of backups, because after finishing the
backup if another backup is requested we will wait for the availability of
the RR and wait until RR integrity is established using the algorithm proposed
 above.

Pros:

- No need to use Neo4j client
- Simple implementation using curl

Cons:

- May not cover all scenarios
